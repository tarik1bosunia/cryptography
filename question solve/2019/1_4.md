# Section-A Answers

## 1.

### (a) What do you mean by Authentication, Integrity and Nonrepudiation?

* **Authentication:** Process of verifying the identity of a user, device, or entity. Examples: passwords, digital signatures, Kerberos tickets. Ensures the communicating party is who they claim to be.
* **Integrity:** Assurance that data has not been altered in an unauthorized way during storage or transit. Techniques: cryptographic hashes (SHA family), MACs (HMAC). If the receiver computes the same digest as the sender, integrity holds.
* **Nonrepudiation:** Prevents an entity from denying a previously performed action (e.g., sending a message). Digital signatures using the sender’s private key provide nonrepudiation because only the signer could have created the signature.

---

### (b) Briefly discuss

**(i) Ciphertext-only attack**

* Attacker has access only to one or more ciphertexts and attempts to deduce plaintexts or keys using statistical analysis, frequency analysis (classical ciphers), or pattern detection. Example: frequency analysis against simple substitution ciphers.

**(ii) Adaptive-chosen-plaintext attack**

* Attacker can adaptively choose plaintexts and obtain corresponding ciphertexts; choices may depend on earlier results. Very powerful against schemes that leak information (block-cipher modes, padding oracle vulnerabilities). Used in analyzing modern ciphers and protocols.

**(iii) Rubber‑hose attacks**

* Nontechnical/coercive attack where an adversary extracts keys or secrets by threatening or physically forcing a user to reveal them. Emphasizes that human factors are often the weakest link.

---

### (c) Differentiate between substitution cipher and transposition cipher with example

* **Substitution cipher:** Each symbol in plaintext is replaced by another symbol. Example: Caesar cipher (shift by 3): `ATTACK` → `DWWDFN`.
* **Transposition cipher:** Symbols are rearranged without changing the symbols themselves. Example: Columnar transposition with width 3, plaintext `ATTACKNOW` written in rows:

  ```
  A T T
  A C K
  N O W
  ```

  Read column-wise → `A A N T C O T K W` → `AANTCOTKW`.

**Key difference:** Substitution changes the identity of characters; transposition changes their order. Many practical systems combine both for stronger security.

---

## 2.

### (a) What is protocol? Discuss communication using Symmetric cryptography

* **Protocol:** A defined set of rules that govern communication between entities (message formats, timing, error handling, security steps).

**Symmetric-cryptography communication example:**

1. Two parties (Alice, Bob) share a symmetric key `K` (secure channel or key distribution mechanism used initially).
2. Alice prepares message `M`, computes `C = Enc_K(M)` (e.g., AES-CBC), optionally computes `MAC = HMAC_K(M)` and sends `C || MAC` to Bob.
3. Bob receives `C || MAC`, decrypts `M' = Dec_K(C)`, verifies `MAC` with `HMAC_K(M')`. If MAC matches, message is authentic and intact.

Advantages: fast, suitable for bulk encryption. Disadvantage: secure key distribution and key management required.

---

### (b) Briefly discuss the following terms

**One‑way function:** A function easy to compute but hard to invert (given y, hard to find x with f(x)=y). Example: modular exponentiation `f(x)=g^x mod p`.

**Trapdoor one‑way function:** A one-way function that becomes easy to invert given some secret information (the trapdoor). Example: RSA `f(x)=x^e mod n` is invertible if you know the private exponent `d`.

**Hash function (one‑way hash) with example:** A deterministic function that maps arbitrary-length input to fixed-length digest; designed to be preimage-resistant and collision-resistant. Example: SHA-256: SHA-256("hello") = a hashed 256-bit value.

---

### (c) Explain birthday attack

* **Birthday attack** exploits the birthday paradox: for an n-bit hash, collisions can be found in about `2^{n/2}` work rather than `2^n`.
* Example: For a 128-bit hash, collisions expected in ~`2^{64}` operations. Attack method: generate many messages, hash them, store hashes, and look for collisions in the collection.

Implication: choose sufficiently long hash outputs (e.g., 256 bits) to resist practical collision attacks.

---

## 3.

### (a) How can you store, update, distribute and verify keys? Explain.

* **Storage:** Use secure hardware (HSMs, TPMs), OS-protected keystores, or encrypted key files protected by strong passphrases.
* **Update (Key Rotation):** Periodically generate new keys, re-encrypt data (or use key-wrapping), expire old keys, and revoke compromised keys.
* **Distribution:** Use secure channels — physical exchange for OTPs, PKI (certificate authorities) for public keys, or key distribution services (KDC like Kerberos) for symmetric keys.
* **Verification:** Use certificates signed by trusted CAs, certificate chains, or challenge-response mechanisms (prove possession of private key by signing a nonce).

Good key management includes backup (secure, encrypted), access control, audit logging, and automated rotation policies.

---

### (b) No encryption key should be used for an indefinite period. Why?

* **Reasons to rotate keys:**

  * Limits damage if a key is compromised.
  * Reduces window of vulnerability for replay or long-term cryptanalysis.
  * Prevents accumulation of encrypted data under one key which eases cryptanalysis.
* **Operational reasons:** algorithm upgrades, policy changes, personnel changes.

Best practice: define key lifetimes and automate rotation.

---

### (c) What is the role of prime number in public key cryptography? Discuss prime number generation technique in real world.

* **Role:** Many public-key algorithms (RSA, Diffie–Hellman) rely on properties of primes — e.g., RSA uses large primes `p, q` to form modulus `n = p·q`; security rests on difficulty of factoring `n`.

**Prime generation techniques:**

1. **Random candidate generation:** generate random odd numbers of desired bit-length.
2. **Preliminary sieving:** reject numbers divisible by small primes.
3. **Probabilistic primality tests:** Miller–Rabin or Baillie‑PSW run multiple rounds to assert primality with negligible error.
4. **Strong prime requirements (historical):** some systems requested primes with certain properties, though modern practice focuses on size and randomness.

Real-world use: Generate 2048-bit (or larger) primes using cryptographically secure RNG + multiple Miller–Rabin iterations.

---

## 4.

### (a) Why is it important to update the keys? Discuss the process of destroying the old keys.

* **Importance:** Key updates (rotation) limit exposure from key compromise, improve forward secrecy, and meet compliance policies.

**Destroying old keys:**

1. **Revoke** the old key in key directories/PKI and publish CRLs or use OCSP for certificates.
2. **Wipe** key material from memory and storage (secure deletion, overwrite).
3. **Archive securely** if needed for forensics (encrypt and restrict access) or securely shred if not needed.
4. **Re-encrypt** or re-wrap stored data using new keys when necessary.

Proper logging and verification of key destruction must be part of the process.

---

### (b) Discuss the effect of reduced key space.

* **Reduced key space** (shorter keys or limited entropy) makes brute-force attacks feasible. E.g., 56-bit keys (DES) are breakable by modern hardware in practical time.
* **Consequences:** easier brute force, faster dictionary/rainbow attacks, lowered computational security margin.

---

### (c) What do you mean by dictionary attack? Write the effect of poor key choice.

* **Dictionary attack:** Attacker tries a precompiled list of likely passwords (words, common phrases) against a password hash or login interface.

**Effect of poor key/password choice:**

* Simple, common, or short passwords vastly reduce time to crack (dictionary + brute force).
* Reusing passwords across systems multiplies risk.
* Predictable keys defeat the theoretical strength of cryptographic algorithms even if algorithms are strong.

**Mitigation:** enforce long passphrases, complexity, rate-limiting, account lockout, salts, and use slow KDFs (bcrypt, Argon2).
