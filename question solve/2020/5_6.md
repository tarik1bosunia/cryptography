## Question 5 Answers

### (a) Criticisms against the Digital Signature Algorithm (DSA)

**Digital Signature Algorithm (DSA)** is a U.S. government standard for digital signatures (defined in FIPS 186). While it provides message integrity and authentication, it has faced several criticisms:

1. **Dependence on Randomness:**

   * DSA requires a random number `k` for each signature. If `k` is reused or predictable, the private key can be easily exposed (e.g., Sony PS3 vulnerability).

2. **Performance Limitations:**

   * Slower than RSA for verification operations, which makes it less efficient for large-scale systems.

3. **Patent and Standardization Issues:**

   * Early versions were covered by patents and were restricted to certain key sizes (e.g., 1024-bit limit in older standards).

4. **No Encryption Capability:**

   * DSA can only sign data—it cannot be used for encryption or key exchange.

5. **Susceptibility to Implementation Flaws:**

   * Weak randomness or poor implementation may lead to private key leakage.

**Example Issue:**
If the random number `k` repeats, the attacker can compute the private key as:
`x = (s*k - H(m)) * r⁻¹ mod q`

---

### (b) What is Kerberos? How does Kerberos Work?

**Kerberos:**
Kerberos is a **trusted third-party authentication protocol** designed for secure authentication over **TCP/IP networks**. It uses **symmetric key cryptography** and a central authority known as the **Key Distribution Center (KDC)**.

**KDC Components:**

1. **Authentication Server (AS)** – Verifies user identity and issues Ticket Granting Ticket (TGT).
2. **Ticket Granting Server (TGS)** – Issues service tickets for access to specific network services.

**Working Steps:**

1. **Login/Initial Request:**
   User → AS: Sends a request for a Ticket Granting Ticket (TGT).
2. **AS Response:**
   AS → User: Returns encrypted TGT + session key.
3. **Request for Service Ticket:**
   User → TGS: Sends TGT and service request.
4. **TGS Response:**
   TGS → User: Issues service ticket + new session key.
5. **Service Access:**
   User → Service Server: Sends the service ticket; mutual authentication ensures both client and server trust each other.

**Result:**
Authentication is achieved without transmitting passwords over the network.

---

### (c) Kerberos Credentials

Kerberos uses two main types of credentials for authentication and secure access:

1. **Ticket-Granting Ticket (TGT):**

   * Issued by the Authentication Server after the initial login.
   * Used to request additional service tickets from the TGS without re-entering credentials.
   * Contains user ID, session key, and expiration time.

2. **Service Ticket:**

   * Issued by the TGS for accessing a particular service.
   * Contains client ID, server ID, and a session key shared between client and server.

**Other Credentials:**

* **Session Keys:** Temporary symmetric keys used for secure communication.
* **Authenticators:** Encrypted timestamps that prevent replay attacks.

**Summary:**
Kerberos ensures mutual authentication, time-based validity, and secure exchange of session keys — reducing the risk of password interception or replay attacks.

---

## Question 6 Answers

### (a) How a Public‑Key Authority (PKA) works (public‑key distribution technique)

A **Public‑Key Authority** is an online, trusted third party that vouches for users’ public keys in real time.

**Workflow:**

1. **Registration:** Each user securely registers their identity and public key with the PKA. The PKA stores `(UserID, PublicKey)` and protects it with its own master key.
2. **Query:** When Alice wants Bob’s public key, she sends the PKA a request containing Bob’s ID (often with a nonce/timestamp for freshness).
3. **Response:** The PKA returns a signed certificate‐style record, e.g.
   `E_{SK_PKA}{ Bob, PU_B, timestamp, expiry }`
   Alice verifies the signature using the **PKA’s public key**. Optionally, the PKA sends the response encrypted for Alice and includes Alice’s nonce so she knows it’s fresh.
4. **Use:** After verification, Alice can safely use `PU_B` to encrypt to Bob or verify Bob’s signatures.

**Why it helps:** prevents **man‑in‑the‑middle** substitution of public keys without requiring offline distribution. (It’s conceptually similar to a CA, but answers live queries.)

---

### (b) Diffie–Hellman key exchange (q = 353, primitive root α = 3)

Given secrets:
A’s secret **X_A = 97**, B’s secret **X_B = 233**.

**Public values:**

* `Y_A = α^{X_A} mod q = 3^{97} mod 353 = 40`
* `Y_B = α^{X_B} mod q = 3^{233} mod 353 = 248`

**Shared key:**

* `K = (Y_B)^{X_A} mod q = 248^{97} mod 353 = 160`
  (equivalently `K = (Y_A)^{X_B} mod q = 40^{233} mod 353 = 160`)

✅ Both sides compute the same session key: **K = 160**.

---

### (c) What is PGP? Confidentiality & Authentication (with diagram)

**PGP (Pretty Good Privacy)** is a hybrid cryptosystem for email/files that provides **confidentiality, integrity, and authentication**.

**High‑level steps:**

1. **Hash & Sign (Authentication):**
   `h = Hash(M)` → `Sig = Sign_{SK_sender}(h)`
2. **Compress:** `(M || Sig)` is compressed (reduces size and patterns).
3. **Encrypt (Confidentiality):**
   Generate random **session key K_s** → encrypt the compressed data with a symmetric cipher (e.g., AES/IDEA): `C = Enc_{K_s}(compressed(M||Sig))`.
4. **Encrypt Session Key for Recipient(s):**
   `E_s = Enc_{PU_recipient}(K_s)` (for each recipient).
5. **ASCII Armor:** Convert to Radix‑64 for email compatibility.

**On receive:** decrypt `E_s` with `SK_recipient` to get `K_s` → decrypt `C` → decompress → verify signature with sender’s **public key**.

**Neat diagram:**

```
           Authentication path                      Confidentiality path
M ──Hash──► h ──Sign(SK_S)──► Sig ┐
                                   │  (concat)
                           ┌───────┴────────┐
                           │  (M || Sig)    │
                           └───────┬────────┘
                                 Compress
                                    │
                                    ▼
                               Symmetric Enc
                              with session K_s  ───────────►  C
                                    ▲                              
                 PU_R ─Encrypt─── K_s ──► E_s (per recipient)

Send:  E_s  +  C   →  (Radix‑64 / ASCII armor)

Receive:  SK_R decrypts E_s → K_s;  Dec_{K_s}(C) → (M||Sig);  Verify Sig with PU_S
```

**Outcome:**

* **Confidentiality:** via `Enc_{K_s}(…)` and public‑key wrapping of `K_s`.
* **Authentication & Integrity:** via the sender’s digital signature.
