# Cryptography Question 4 Solutions

---

## 4(a) What is a digital signature? Explain hash functions and digital signatures.

**Digital Signature (DS):**
A digital signature is a cryptographic mechanism that lets a sender attach a verifiable, tamper‑evident seal to digital data. Anyone can verify who signed (authenticity) and that the content has not changed (integrity). In legal/enterprise settings it also supports **non‑repudiation** (the signer cannot credibly deny signing).

**Why we use a hash with DS:**
Directly signing large messages is slow. Instead we compute a short **hash** of the message and sign that hash. This gives speed and binds the signature to the exact message bits.

**Required properties of a cryptographic hash function** $H$:

* **Preimage resistance:** Given $y$, hard to find $x$ such that $H(x)=y$.
* **Second‑preimage resistance:** Given $x$, hard to find $x'\neq x$ with $H(x')=H(x)$.
* **Collision resistance:** Hard to find **any** $x\neq x'$ with the same hash. (For an $n$-bit hash, naive cost \~$2^{n/2}$ by the birthday bound.)

**How a standard digital signature (e.g., RSA, ECDSA) works:**

1. Sender computes $h=H(m)$.
2. **Sign:** Using private key `sk`, compute signature `s = Sign(sk, h)` (e.g., RSA: $s = h^d \bmod n$).
3. **Verify:** Receiver recomputes $h'=H(m)$ and checks `Verify(pk, h', s)` (e.g., RSA: check $s^e \equiv h' \pmod n$).
   If the check holds, the message and signer are authenticated and the content is intact.

---

## 4(b) Write down the properties of a digital signature

* **Authenticity:** Confirms the signer’s identity (only holder of the private key could have produced it).
* **Integrity:** Any change in the message changes the hash; verification fails.
* **Non‑repudiation:** Signer cannot deny having signed later.
* **Unforgeability:** Computationally infeasible to create a valid signature without the private key.
* **Verifiability / Public verifiability:** Anyone with the public key can verify.
* **Efficiency:** Sign and verify operations should be practical; hashing enables this.

*Good practice:* Use modern hashes (e.g., SHA‑256/512) and appropriate key sizes (e.g., RSA‑2048/3072 or ECDSA P‑256/P‑384).

---

## 4(c) RSA example: Encrypt and decrypt m = 1010567890987 with n = 3337, e = 79, d = 1019

> In RSA the numerical message **block** must be smaller than $n$. Since `n = 3337`, we split the long number into 3‑digit blocks (each < 1000 < 3337). We preserve leading zeros when needed.

**Split into 3‑digit blocks (left→right):**

```
101 | 056 | 789 | 098 | 007
```

Let the blocks be: $[101, 056, 789, 098, 007]$.

### Encrypt each block with the public key (e = 79, n = 3337)

For each block $m_i$: $c_i = m_i^{79} \bmod 3337$.

| Block (m\_i) | c\_i = m\_i^79 mod 3337 |
| -----------: | ----------------------: |
|          101 |                    1113 |
|          056 |                    2780 |
|          789 |                     961 |
|          098 |                     617 |
|          007 |                    1254 |

**Ciphertext blocks:** `[1113, 2780, 961, 617, 1254]`

*(In practice these would be serialized with fixed width; here we show them in a table.)*

### Decrypt each block with the private key (d = 1019)

For each cipher $c_i$: $m_i' = c_i^{1019} \bmod 3337$.

| Cipher (c\_i) | m\_i' = c\_i^1019 mod 3337 |
| ------------: | -------------------------: |
|          1113 |                        101 |
|          2780 |                         56 |
|           961 |                        789 |
|           617 |                         98 |
|          1254 |                          7 |

After zero‑padding back to 3 digits (`101 | 056 | 789 | 098 | 007`) and concatenating, we recover:

```
1010567890987
```

**Hence decryption reproduces the original message m.**

> **Key takeaways:**
>
> * RSA operates on integers < n; long messages are handled in blocks (or with padding schemes like PKCS#1 v1.5/OAEP for security).
> * Correctness follows from $m^{ed} \equiv m \pmod n$ when $ed \equiv 1\pmod{\varphi(n)}$.
