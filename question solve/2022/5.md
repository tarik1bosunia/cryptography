# Cryptography Question 5 Solutions

---

## 5(a) What is Kerberos? Briefly discuss Kerberos credentials.

**Kerberos** is a network authentication protocol (by MIT) that uses symmetric‑key cryptography and a trusted third party—**Key Distribution Center (KDC)**—to provide **mutual authentication** between clients and services over an insecure network. It avoids sending passwords over the wire and issues time‑limited **tickets** instead.

Kerberos realms typically run two logical services inside the KDC:

* **AS (Authentication Server)**
* **TGS (Ticket‑Granting Server)**

> **Clock sync is essential** (e.g., ±5 minutes) because Kerberos uses timestamps to defeat replay.

### Core credentials (what they are and how they’re used)

* **Long‑term keys**

  * *Client long‑term key*: derived from the user’s password; shared with KDC (not sent on network).
  * *Server/service long‑term key*: stored in the service’s *keytab*; shared with KDC.
* **TGT – Ticket‑Granting Ticket**
  Issued by the AS. It’s encrypted with the **TGS’s secret key**, so only the TGS can read it. Contains:

  * client ID, client network addr
  * **client↔TGS session key** $K\_{c,tgs}$
  * start time, lifetime
* **Service Ticket**
  Issued by the TGS for a target service *S*; encrypted with **S’s secret key**. Contains:

  * client ID, addr, validity window
  * **client↔service session key** $K\_{c,s}$
* **Authenticator**
  Small blob the client creates for each request (ID + timestamp), **encrypted with the appropriate session key** (either $K\_{c,tgs}$ or $K\_{c,s}$). Proves “freshness” and that the client knows the session key.

### One‑screen protocol flow

```
AS-REQ:  C → AS : (C, realm, request TGS) [+ preauth]
AS-REP:  AS → C : {Kc,tgs}Kc   ||   TGT={C,addr,time,lifetime,Kc,tgs}Ktgs

TGS-REQ: C → TGS: TGT, Authenticator(Kc,tgs), request ticket for S
TGS-REP: TGS→ C : {Kc,s}Kc,tgs   ||   TicketS={C,addr,time,lifetime,Kc,s}Ks

AP-REQ:  C →  S : TicketS, Authenticator(Kc,s)
AP-REP:  S →  C : {timestamp+1}Kc,s   (mutual auth)
```

**Result:** C and S share $K\_{c,s}$ and can start protected application traffic.

---

## 5(b) Briefly discuss **public‑key authority** technique to distribute public keys

Before certificates were common, one approach was an **online Public‑Key Authority (PKA)**: a trusted server maintains a live directory that securely answers “What is B’s public key?”

**Idea and steps (with nonces/timestamps to stop replay):**

1. **A → PKA:** request B’s public key, send identity of A and a fresh nonce $N\_A$.
2. **PKA → A:** replies **signed (or MACed) by PKA** with $[B, PK\_B, timestamp]$ and echoes $N\_A$. A verifies signature and freshness, then trusts $PK\_B$.
3. Optionally the PKA notifies B or both parties to bind the query (mutual confirmation).

**Pros:** Simple trust model; revocations are immediate because keys come from the live directory.
**Cons:** PKA is online for every lookup (latency, single point of failure). To remove this online dependency we use **public‑key certificates** (e.g., X.509): the CA **signs** $[ID, PK]$ offline; anyone can verify the CA signature without contacting it, while revocation is handled via CRLs/OCSP.

---

## 5(c) Diffie–Hellman key exchange

Given: prime $q=353$, primitive root $\alpha=3$, secrets $x_A=97$, $x_B=233$.

**Public keys**

**Public keys (no LaTeX):**

```
y_A = 3^97 mod 353 = 40
y_B = 3^233 mod 353 = 248
```

**Shared secret** (computed both ways)

**Shared secret (no LaTeX):**

```
K = 248^97 mod 353 = 160
K = 40^233 mod 353 = 160
```

So A and B agree on the **shared key: `160`**.

> *Computation hint (square‑and‑multiply):* Write exponents in binary (e.g., $97=1100001_2$) and iteratively square modulo 353; multiply only where a bit is 1.

---

### Quick takeaways

* Kerberos uses **tickets + session keys** from a KDC; no passwords are sent, and clocks must be in sync.
* A **Public‑Key Authority** is an *online* signed directory; **certificates** are *offline* signed statements.
* Diffie–Hellman derives a common key $g^{ab}$ mod $p$ without ever sending $a$ or $b$.

---

## 5(c) Step-by-step (parse-friendly, no LaTeX)

Goal: q = 353, alpha = 3, xA = 97, xB = 233.

### Public keys via square-and-multiply

1. Powers of 3 mod 353 (by repeated squaring):

   * 3^1=3, 3^2=9, 3^4=81, 3^8=207, 3^16=136, 3^32=140, 3^64=185, 3^128=337.
2. 97 = 64 + 32 + 1 ⇒ yA = 3^97 mod 353 = (185 \* 140 \* 3) mod 353 = 40.
3. 233 = 128 + 64 + 32 + 8 + 1 ⇒ yB = 3^233 mod 353 = (337 → *185* → *140* → *207* → *3*) stepwise mods: 337, 217, 22, 318, 248 ⇒ yB = 248.

### Shared secret (compute both ways)

* Using yB^xA: precompute base 248 squares mod 353

  * 248^1=248, 248^2=82, 248^4=17, 248^8=289, 248^16=213, 248^32=185, 248^64=337.
  * 97 = 64 + 32 + 1 ⇒ K = (337 \* 185 \* 248) mod 353 = 160.
* Using yA^xB: base 40 squares mod 353

  * 40^1=40, 40^2=188, 40^4=44, 40^8=171, 40^16=295, 40^32=187, 40^64=22, 40^128=131.
  * 233 = 128 + 64 + 32 + 8 + 1 ⇒ step products: 131, 58, 256, 4, 160 ⇒ K = 160.

**Answer:** The Diffie–Hellman shared key is **160**. These arithmetic steps avoid special formatting so they should parse cleanly anywhere.
