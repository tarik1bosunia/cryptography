# SHA (Secure Hash Algorithm)

This guide shows two ways to compute a **one‑way hash** with SHA:

1. **Real‑world** usage with Python’s built‑in `hashlib` (recommended)
2. An **educational, from‑scratch** implementation of **SHA‑256** (padding, message schedule, 64 rounds), verified with standard test vectors

> ⚠️ Notes
>
> * **SHA‑1 is broken** for collision resistance; do **not** use it.
> * Prefer **SHA‑256** or **SHA‑512** (or stronger, depending on security needs).

---

## ✅ Quick (real‑world) usage — `hashlib`

```python
import hashlib

def sha256_hex(data: bytes) -> str:
    return hashlib.sha256(data).hexdigest()

print(sha256_hex(b"hello"))  # -> 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
```

### Hash a large file (streaming)

```python
import hashlib
from pathlib import Path

def sha256_file_hex(path: str, bufsize: int = 1 << 20) -> str:
    h = hashlib.sha256()
    with open(path, 'rb') as f:
        while chunk := f.read(bufsize):
            h.update(chunk)
    return h.hexdigest()

print(sha256_file_hex("some_file.bin"))
```

---

## 🧩 SHA‑256 From Scratch (Educational)

This implementation follows FIPS‑180‑4:

1. **Pad** the message: `0x80`, then `0x00` bytes until length ≡ 448 (mod 512)
2. Append original length in **bits** as a **64‑bit big‑endian** integer
3. Initialize 8 state words `H0..H7`
4. For each 512‑bit block, build **message schedule** `W[0..63]` and run **64 rounds**
5. Output concatenation of updated `H0..H7` as 32‑byte digest

```python
from __future__ import annotations
from typing import Iterable
from struct import pack, unpack

# --- Bit ops ---
MASK32 = 0xFFFFFFFF

def _rotr(x: int, n: int) -> int:
    x &= MASK32
    return ((x >> n) | ((x & MASK32) << (32 - n))) & MASK32

def _shr(x: int, n: int) -> int:
    return (x & MASK32) >> n

# SHA‑256 logical functions
Ch  = lambda x, y, z: (x & y) ^ (~x & z)
Maj = lambda x, y, z: (x & y) ^ (x & z) ^ (y & z)
Sigma0 = lambda x: _rotr(x, 2)  ^ _rotr(x, 13) ^ _rotr(x, 22)
Sigma1 = lambda x: _rotr(x, 6)  ^ _rotr(x, 11) ^ _rotr(x, 25)
sigma0 = lambda x: _rotr(x, 7)  ^ _rotr(x, 18) ^ _shr(x, 3)
sigma1 = lambda x: _rotr(x, 17) ^ _rotr(x, 19) ^ _shr(x, 10)

# Initial hash values (first 32 bits of fractional parts of sqrt of primes 2..19)
H0 = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
]

# Round constants (first 32 bits of fractional parts of cube roots of primes 2..311)
K = [
    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2,
]

class SHA256:
    def __init__(self) -> None:
        self._H = H0.copy()
        self._buf = b""
        self._length = 0  # bytes seen

    def update(self, data: bytes) -> "SHA256":
        self._length += len(data)
        data = self._buf + data
        # process complete 64‑byte chunks
        for i in range(0, (len(data) // 64) * 64, 64):
            self._compress(data[i:i+64])
        self._buf = data[(len(data) // 64) * 64:]
        return self

    def _compress(self, chunk: bytes) -> None:
        assert len(chunk) == 64
        W = list(unpack('>16I', chunk)) + [0]*48
        for t in range(16, 64):
            W[t] = (sigma1(W[t-2]) + W[t-7] + sigma0(W[t-15]) + W[t-16]) & MASK32

        a,b,c,d,e,f,g,h = self._H
        for t in range(64):
            T1 = (h + Sigma1(e) + Ch(e,f,g) + K[t] + W[t]) & MASK32
            T2 = (Sigma0(a) + Maj(a,b,c)) & MASK32
            h, g, f, e, d, c, b, a = g, f, e, (d + T1) & MASK32, c, b, a, (T1 + T2) & MASK32

        H = self._H
        self._H = [
            (H[0] + a) & MASK32,
            (H[1] + b) & MASK32,
            (H[2] + c) & MASK32,
            (H[3] + d) & MASK32,
            (H[4] + e) & MASK32,
            (H[5] + f) & MASK32,
            (H[6] + g) & MASK32,
            (H[7] + h) & MASK32,
        ]

    def digest(self) -> bytes:
        bit_len = (self._length * 8) & ((1 << 64) - 1)
        # pad: 0x80 then zeros so that (len + 1 + pad) % 64 == 56
        pad_zero_len = (56 - (self._length + 1) % 64) % 64
        tail = b"\x80" + b"\x00" * pad_zero_len + pack('>Q', bit_len)
        self.update(tail)
        # return big‑endian 32‑byte digest
        return pack('>8I', *self._H)

    def hexdigest(self) -> str:
        return ''.join(f"{b:02x}" for b in self.digest())

# Convenience

def sha256_hex(data: bytes) -> str:
    return SHA256().update(data).hexdigest()

# --- Self‑test vectors (FIPS 180‑4) ---
if __name__ == "__main__":
    vectors = {
        b"": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
        b"abc": "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad",
        b"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq": "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1",
    }
    ok = True
    for msg, expected in vectors.items():
        got = sha256_hex(msg)
        print(msg, got, ("OK" if got == expected else "FAIL"))
        ok &= (got == expected)
    print("All tests passed" if ok else "Some tests FAILED")
```

---


## 🔒 Security notes

* For password hashing, **do not** use raw SHA‑256. Use **Argon2**, **scrypt**, or **bcrypt**.
* SHA‑256 is collision‑resistant for today’s typical use, but always check current guidance for your domain.
