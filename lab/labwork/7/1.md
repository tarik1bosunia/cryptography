# Miller–Rabin Primality Test — VS Code–Friendly Guide + Python

The **Miller–Rabin test** is a fast *probabilistic* primality test. For 64‑bit integers you can also make it **deterministic** by using a fixed small set of bases.

---

## Idea (plain text)

Given an odd integer `P > 2`, write `P − 1 = d * 2^s` with `d` odd. For a base `a` in `[2, P−2]`, compute

* `x = pow(a, d, P)`
* If `x == 1` or `x == P-1`, this base passes.
* Otherwise repeat up to `s−1` times: set `x = (x*x) % P`; if `x == P-1`, this base passes; if we finish without seeing `P-1`, **composite**.

If all chosen bases pass, `P` is **probable prime**.

> Deterministic for 64‑bit: testing bases `a ∈ {2, 3, 5, 7, 11, 13, 17}` is enough for all `P < 2^64`.

---

## Python Implementation

```python
from typing import Iterable

_SMALL_PRIMES = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29)

def _trial_division(n: int) -> int:
    """Return a small prime factor of n if found, else 0. Quick rejects."""
    for p in _SMALL_PRIMES:
        if n % p == 0:
            return p
    return 0

def _decompose(n: int):
    """Return (d, s) such that n = d * 2^s with d odd."""
    s = 0
    d = n
    while d % 2 == 0:
        d //= 2
        s += 1
    return d, s

def _check_a(n: int, d: int, s: int, a: int) -> bool:
    """One Miller–Rabin round for base a."""
    x = pow(a, d, n)
    if x == 1 or x == n - 1:
        return True
    for _ in range(s - 1):
        x = (x * x) % n
        if x == n - 1:
            return True
    return False

def is_probable_prime(n: int, bases: Iterable[int] | None = None) -> bool:
    """Miller–Rabin primality test.
    If bases is None, choose a deterministic set for 64-bit integers.
    Returns True for probable prime, False for composite.
    """
    if n < 2:
        return False
    # small primes and even check
    if n in _SMALL_PRIMES:
        return True
    if n % 2 == 0:
        return False
    if _trial_division(n):
        return False  # divisible by a small prime

    d, s = _decompose(n - 1)

    # Deterministic bases for n < 2^64
    if bases is None:
        bases = (2, 3, 5, 7, 11, 13, 17)

    for a in bases:
        if a % n == 0:
            continue  # skip if base equals n
        if not _check_a(n, d, s, a):
            return False
    return True

# Convenience reporter

def miller_rabin_report(n: int) -> str:
    return f"{n} is {'PRIME' if is_probable_prime(n) else 'COMPOSITE'} (Miller–Rabin, 64-bit deterministic bases)."

if __name__ == "__main__":
    tests = [2, 3, 4, 5, 7, 9, 11, 15, 21, 97, 221, 561, 1105, 2**61-1, 10**9 + 7]
    for t in tests:
        print(miller_rabin_report(t))
```

---

## Notes

* Handles trivial cases and quick small‑prime rejections.
* Uses Python’s built‑in `pow(base, exp, mod)` for fast modular exponentiation.
* Deterministic for all `n < 2^64` with bases `(2,3,5,7,11,13,17)`.
* For larger integers, pass more random bases: e.g., 10–20 rounds yields very high confidence.

---

## Example output

```
2 is PRIME (Miller–Rabin, 64-bit deterministic bases).
3 is PRIME (Miller–Rabin, 64-bit deterministic bases).
4 is COMPOSITE (Miller–Rabin, 64-bit deterministic bases).
...
97 is PRIME (Miller–Rabin, 64-bit deterministic bases).
221 is COMPOSITE (Miller–Rabin, 64-bit deterministic bases).
561 is COMPOSITE (Miller–Rabin, 64-bit deterministic bases).
```
