# RSA Encryption & Decryption — Strings (ASCII) and Integers (Python)

This is a **teaching** implementation of textbook RSA (no padding). It supports:

* **Integers** directly (must be `< n`)
* **Strings** by converting to **ASCII bytes** first (as required), chunking to fit under `n`, then reassembling.

> ⚠️ **Security note**: Textbook RSA **without padding (OAEP/PKCS#1 v1.5)** is **not secure**. Use this for coursework only.

---

## What the program does

1. **Key generation**: `n = p*q`, public exponent `e = 65537`, private exponent `d ≡ e⁻¹ (mod φ(n))`.
2. **Encrypt integer**: `c = m^e mod n`.
3. **Decrypt integer**: `m = c^d mod n`.
4. **Encrypt string**: ASCII-encode → add a 4‑byte length header → split into blocks that fit under `n` → encrypt each block.
5. **Decrypt string**: decrypt blocks → join bytes → read the 4‑byte length to recover the exact original.

---

## Full Python Program (VS Code friendly)

```python
import secrets
from typing import List, Tuple

# ---------------- Miller–Rabin (deterministic for 64-bit; probabilistic beyond) ----------------
_SMALL_PRIMES = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29)

def _trial_division(n: int) -> int:
    for p in _SMALL_PRIMES:
        if n % p == 0:
            return p
    return 0

def _decompose(n: int) -> Tuple[int, int]:
    s = 0
    d = n
    while d % 2 == 0:
        d //= 2
        s += 1
    return d, s

def _check_a(n: int, d: int, s: int, a: int) -> bool:
    x = pow(a, d, n)
    if x == 1 or x == n - 1:
        return True
    for _ in range(s - 1):
        x = (x * x) % n
        if x == n - 1:
            return True
    return False

def is_probable_prime(n: int) -> bool:
    if n < 2:
        return False
    if n in _SMALL_PRIMES:
        return True
    if n % 2 == 0:
        return False
    if _trial_division(n):
        return False
    # Probabilistic bases for general big integers
    d, s = _decompose(n - 1)
    for a in (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37):
        if a % n == 0:
            continue
        if not _check_a(n, d, s, a):
            return False
    # Additional random bases for higher confidence
    for _ in range(8):
        a = secrets.randbelow(n - 3) + 2  # in [2, n-2]
        if not _check_a(n, d, s, a):
            return False
    return True

# ---------------- Prime generation ----------------

def random_odd(bits: int) -> int:
    x = secrets.randbits(bits)
    x |= 1
    x |= (1 << (bits - 1))  # ensure top bit set
    return x

def gen_prime(bits: int) -> int:
    while True:
        cand = random_odd(bits)
        if is_probable_prime(cand):
            return cand

# ---------------- RSA key generation ----------------

def rsa_keygen(bits: int = 1024) -> Tuple[Tuple[int, int], Tuple[int, int]]:
    """Return (pub=(n,e), priv=(n,d))."""
    e = 65537
    # Generate p, q until gcd(e, phi) == 1
    while True:
        p = gen_prime(bits // 2)
        q = gen_prime(bits // 2)
        if p == q:
            continue
        n = p * q
        phi = (p - 1) * (q - 1)
        if phi % e != 0:  # gcd(e, phi) == 1 if phi % e != 0 and e is prime; else compute gcd
            try:
                d = pow(e, -1, phi)
                return (n, e), (n, d)
            except ValueError:
                pass  # not invertible; try again

# ---------------- Integer RSA ----------------

def rsa_encrypt_int(m: int, pub: Tuple[int, int]) -> int:
    n, e = pub
    if not (0 <= m < n):
        raise ValueError("Integer message m must satisfy 0 <= m < n")
    return pow(m, e, n)

def rsa_decrypt_int(c: int, priv: Tuple[int, int]) -> int:
    n, d = priv
    return pow(c, d, n)

# ---------------- String helpers (ASCII only) ----------------

def ascii_to_bytes(s: str) -> bytes:
    try:
        return s.encode('ascii', errors='strict')
    except UnicodeEncodeError as e:
        raise ValueError("String contains non-ASCII characters; convert or restrict input") from e


def max_block_bytes(n: int) -> int:
    """Largest k such that 256^k < n (so block-as-int fits < n)."""
    k = max(1, (n.bit_length() - 1) // 8)
    # ensure strict inequality
    while (1 << (8 * k)) >= n:
        k -= 1
    return max(1, k)


def bytes_to_int(b: bytes) -> int:
    return int.from_bytes(b, byteorder='big', signed=False)


def int_to_bytes(x: int, length: int) -> bytes:
    return x.to_bytes(length, byteorder='big', signed=False)

# Pack with a 4-byte big-endian length header so we can trim padding on decrypt

def rsa_encrypt_string(msg: str, pub: Tuple[int, int]) -> List[int]:
    n, e = pub
    data = ascii_to_bytes(msg)
    L = len(data)
    header = L.to_bytes(4, 'big')
    payload = header + data
    k = max_block_bytes(n)
    # chunk into k-byte blocks
    blocks = [payload[i:i+k] for i in range(0, len(payload), k)]
    ciphertext_blocks = []
    for b in blocks:
        m = bytes_to_int(b)
        c = rsa_encrypt_int(m, pub)
        ciphertext_blocks.append(c)
    return ciphertext_blocks


def rsa_decrypt_string(cipher_blocks: List[int], priv: Tuple[int, int], n_for_block: int | None = None) -> str:
    n, d = priv
    # determine k from n
    k = max_block_bytes(n if n_for_block is None else n_for_block)
    out = bytearray()
    for c in cipher_blocks:
        m = rsa_decrypt_int(c, priv)
        # We must re-pad each block to exactly k bytes to preserve leading zeros
        b = int_to_bytes(m, k)
        out.extend(b)
    # strip the 4-byte header
    if len(out) < 4:
        raise ValueError("Decryption error: not enough data for length header")
    L = int.from_bytes(out[:4], 'big')
    raw = bytes(out[4:4+L])
    return raw.decode('ascii')

# ---------------- Demo ----------------
if __name__ == "__main__":
    # 1) Keygen (use 1024-bit for demo; 2048+ in practice). This may take a moment.
    pub, priv = rsa_keygen(1024)
    n, e = pub
    print("Public n bits:", n.bit_length())

    # 2) Encrypt/Decrypt an integer message
    m_int = 1234567890
    c_int = rsa_encrypt_int(m_int, pub)
    r_int = rsa_decrypt_int(c_int, priv)
    print("Integer message:", m_int, "→", c_int, "→", r_int)

    # 3) Encrypt/Decrypt a string (ASCII)
    plaintext = "HELLO RSA DEMO"
    cipher_blocks = rsa_encrypt_string(plaintext, pub)
    recovered = rsa_decrypt_string(cipher_blocks, priv)
    print("String message:", plaintext)
    print("Cipher blocks ({}):".format(len(cipher_blocks)))
    print(cipher_blocks[:3], "..." if len(cipher_blocks) > 3 else "")
    print("Recovered:", recovered)
```

---

## How it handles strings (ASCII requirement)

* We **encode to ASCII bytes** (throws an error if any character is non‑ASCII).
* We **prefix 4 bytes** with the original length so we can remove padding after decryption.
* We pick `k = max` bytes such that each `k`‑byte block as an integer is **strictly less than `n`**.
* Each block is encrypted separately with textbook RSA; decryption reconstructs and trims to the exact original string.

---

## Important limitations

* **No padding**: susceptible to deterministic leaks and malleability. Use **RSA‑OAEP** with a standard crypto library for real security.
* **ASCII only** for the string path (as per your requirement). To support Unicode, change `ascii_to_bytes` to UTF‑8 and adjust expectations.
* The demo uses a basic Miller–Rabin and simple prime generation; for robust production RSA, use a vetted library like **cryptography** or **PyCA**.
