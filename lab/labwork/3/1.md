# 🔐 Columnar Transposition Cipher (Width as Input)

This guide shows how to **encrypt** and **decrypt** using a **columnar transposition cipher** where you:

1. **Choose a width** (number of columns),
2. Write the cleaned plaintext row‑wise into a grid of that width,
3. Read off the ciphertext **column‑wise** (top to bottom, left to right),
4. For decryption, reconstruct the grid **column‑wise** and read out row‑wise.

We’ll use the given plaintext:

> **DEPARTMENT OF COMPUTER SCIENCE AND TECHNOLY UNIVERSITY OF RAJSHAHI BANGLADESH**

and show you how to get the ciphertext for any width you choose, then reverse it to the original plaintext.

---

## 🧹 Preprocessing Rules

* Convert to **uppercase**.
* Remove spaces and punctuation (standard for classical ciphers).
* Pad the last row with **X** as needed so the grid is rectangular. (This makes decryption unambiguous.)

> You can always change the `PAD_CHAR` to something else if you prefer.

---

## 🧩 Python Implementation

```python
import math

ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
PAD_CHAR = "X"

# 1) Clean the text: keep A–Z only, uppercase
def clean_text(s: str) -> str:
    s = s.upper()
    return "".join(ch for ch in s if ch in ALPHA)

# 2) Pad to a multiple of width
def pad_text(s: str, width: int, pad: str = PAD_CHAR) -> str:
    remainder = len(s) % width
    if remainder == 0:
        return s
    return s + pad * (width - remainder)

# 3) Encrypt: write row-wise, read column-wise
#    Grid shape: rows = len(s)//width, cols = width

def transposition_encrypt(plaintext: str, width: int) -> tuple[str, str]:
    cleaned = clean_text(plaintext)
    padded = pad_text(cleaned, width)
    rows = len(padded) // width

    # Build grid row-wise
    grid = [padded[r*width:(r+1)*width] for r in range(rows)]

    # Read column-wise to form ciphertext
    cipher = []
    for c in range(width):
        for r in range(rows):
            cipher.append(grid[r][c])
    return "".join(cipher), padded  # also return the padded version for reference

# 4) Decrypt: knowing width and ciphertext length (multiple of width)
#    Rebuild column-wise, then read row-wise

def transposition_decrypt(ciphertext: str, width: int, pad: str = PAD_CHAR) -> str:
    N = len(ciphertext)
    assert N % width == 0, "Ciphertext length must be a multiple of width (use padding during encryption)."
    rows = N // width

    # Split ciphertext into columns (each of length `rows`), left to right
    cols = [ciphertext[c*rows:(c+1)*rows] for c in range(width)]

    # Reconstruct plaintext row-wise
    plain = []
    for r in range(rows):
        for c in range(width):
            plain.append(cols[c][r])
    # Strip trailing padding
    return "".join(plain).rstrip(pad)

# ---------------- Demo with the given plaintext ----------------
PT = "DEPARTMENT OF COMPUTER SCIENCE AND TECHNOLY UNIVERSITY OF RAJSHAHI BANGLADESH"

# Try any width you like, e.g., 5, 6, 8, 10
width = 8
cipher, padded = transposition_encrypt(PT, width)
recovered = transposition_decrypt(cipher, width)

print("Width       :", width)
print("Clean+Pad   :", padded)
print("Ciphertext  :", cipher)
print("Decrypted   :", recovered)
```

---

## 🔎 Worked Example (Width = 8)

Below is a **sample** run for `width = 8`. Your output may differ if you choose a different width, but decryption will always return the original (unspaced) plaintext once padding is removed.

1. **Clean & Pad** (spaces removed, uppercase only, pad with X):

```
DEPARTMENTOFCOMPUTERSCIENCEANDTECHNOLYUNIVERSITYOFRAJSHAHIBANGLADESH
```

This string’s length will be padded to a multiple of 8 if needed.

2. **Fill grid row‑wise** (8 columns), then **read column‑wise** to get ciphertext.

3. **Decrypt** by splitting the ciphertext into 8 equal‑length columns, filling column‑wise, and reading out row‑wise; finally strip trailing X’s.

> 📌 If you need to **preserve original spaces/punctuation**, record their positions before cleaning and re‑insert them after decryption.

---

## 🛠 Notes & Variants

* **Without padding**: Decryption becomes trickier because the last row is incomplete. Padding is recommended for assignments.
* **Reading order**: This guide uses the most common convention (row‑wise fill, column‑wise read). If your course uses a different convention (e.g., column‑wise fill and row‑wise read), just swap the directions consistently for both steps.
* **Width selection**: Wider widths create taller grids (shorter columns) and alter diffusion. Try several widths and compare.

---

## ✅ What to Submit (Typical Assignment)

1. The **width** you used.
2. The **cleaned + padded** plaintext.
3. The resulting **ciphertext**.
4. The **decrypted** plaintext (showing it matches the cleaned original).

---

## 🧪 Quick Test (try a different width)

Change `width = 8` to another value (e.g., 5 or 10) and re‑run. You should always get your original (clean) text back after decryption.
