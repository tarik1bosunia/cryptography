# Lehmann Primality Test — VS Code–Friendly Guide + Python

The **Lehmann** test is a simple *probabilistic* primality check.
It works for odd integers `P > 2`. For a random `a` with `2 ≤ a ≤ P-1`, compute:

* `r = pow(a, (P-1)//2, P)`  (modular exponentiation)
* If `r != 1` **and** `r != P-1`, then **P is composite** (certain).
* If `r == 1` or `r == P-1`, this trial passes; after `k` independent trials, if all pass, report **probable prime** with error at most `2^{-k}`.

> Note: `P-1` represents `-1 mod P` (avoid TeX math so this renders cleanly in VS Code).

---

## Algorithm (Plain Steps)

1. Trivial cases:

   * `P == 2` → prime
   * `P < 2 or P % 2 == 0` → composite
2. Repeat `k` times:

   * Pick random `a` in `[2, P-1]`.
   * Compute `r = pow(a, (P-1)//2, P)`.
   * If `r not in {1, P-1}` → return **composite** immediately.
3. If all trials pass → **probable prime** with error ≤ `2^{-k}`.

---

## Python Implementation (Clean Output in Terminals)

```python
import random
from typing import Tuple

def lehmann_is_probable_prime(P: int, k: int = 10) -> Tuple[bool, float]:
    """Lehmann primality test.
    Returns: (is_probable_prime, error_bound)
    If the function returns False, the number is definitely composite.
    If True, it's a probable prime with error <= 2^{-k}.
    """
    # Trivial cases
    if P == 2:
        return True, 0.0
    if P < 2 or P % 2 == 0:
        return False, 0.0

    # k randomized trials
    for _ in range(k):
        a = random.randrange(2, P)  # 2 <= a <= P-1
        r = pow(a, (P - 1) // 2, P)
        if r != 1 and r != P - 1:
            # definitely composite
            return False, 0.0

    # all trials passed → probable prime
    return True, 2.0 ** (-k)


def lehmann_report(P: int, k: int = 10) -> str:
    probable, err = lehmann_is_probable_prime(P, k)
    if probable:
        return (
            f"P = {P} is PROBABLY PRIME (Lehmann, k={k}).\n"
            f"Worst-case error <= {err:.2e}."
        )
    else:
        return f"P = {P} is COMPOSITE (witness found within {k} trial(s))."


if __name__ == "__main__":
    tests = [2, 3, 5, 7, 11, 15, 21, 97, 221, 561, 1105, 1729, 10**9 + 7]
    for n in tests:
        print(lehmann_report(n, k=12))
```

---

## Usage (VS Code)

* Save as `lehmann.py`.
* Run in the built-in terminal: `python lehmann.py`.
* Or import and call `lehmann_report(P, k)` from your own script.

---

## Notes & Gotchas (Plain Text)

* Even numbers greater than 2 are composite.
* Carmichael numbers (e.g., 561, 1105, 1729) can pass many tests; use more trials (`k`) to reduce error.
* For stronger tests, compare with Miller–Rabin. For deterministic results over bounded ranges, use known MR bases.

---

## Example Output (No TeX/Math Formatting)

```
P = 97 is PROBABLY PRIME (Lehmann, k=12).
Worst-case error <= 2.44e-04.
P = 221 is COMPOSITE (witness found within 12 trial(s)).
```
