# 🔐 Polygram Substitution (Hill Cipher, Block Size = 3)

This guide shows how to encrypt and decrypt a plaintext using a **polygram substitution cipher** with **block size 3** via the **Hill cipher**. The Hill cipher treats each block of 3 letters as a 3‑dimensional vector and applies a 3×3 key matrix modulo 26.

> Why Hill? A polygram (aka polygraphic) substitution maps **groups of letters** to groups of letters. The Hill cipher is the canonical block‑cipher style polygram substitution.

---

## 🚦 Rules & Preprocessing

* Alphabet: A–Z mapped to 0–25.
* Case and spaces/punctuation are ignored during the transform; you may re‑insert them later.
* Block size = 3. If length % 3 ≠ 0, pad with **X**.
* All arithmetic is done **mod 26**.

---

## 🔑 Choosing a Valid Key (3×3)

Let the key matrix be `K` (integers 0–25). To be valid for both encryption and decryption, `det(K)` must be **invertible mod 26** i.e., `gcd(det(K), 26) = 1`.

A simple example key (invertible mod 26):

[
K = \begin{bmatrix}
6 & 24 & 1 \
13 & 16 & 10 \
20 & 17 & 15
\end{bmatrix}
]

This is a classic example from standard treatments of the Hill cipher.

---

## 🧮 Math Recap

* **Encrypt** a block vector `P` (size 3): ( C = K \cdot P \pmod{26} )
* **Decrypt** with ( K^{-1} ): ( P = K^{-1} \cdot C \pmod{26} )
* ( K^{-1} = (\det K)^{-1} \cdot \operatorname{adj}(K) \pmod{26} ), where `(det K)^{-1}` is the modular inverse of `det K (mod 26)`.

---

## 🧩 End‑to‑End Python (Encryption & Decryption)

```python
import numpy as np
from math import gcd

# -------------------- Utilities --------------------
A, Z = ord('A'), ord('Z')

def clean_text(s: str) -> str:
    return ''.join(ch for ch in s.upper() if 'A' <= ch <= 'Z')

def pad_text(s: str, block=3, pad_char='X') -> str:
    r = len(s) % block
    return s if r == 0 else s + pad_char * (block - r)

def to_vec3(tri: str):
    return np.array([[ord(c) - A] for c in tri], dtype=int)  # 3x1

def from_vec3(v: np.ndarray) -> str:
    return ''.join(chr(int(x % 26) + A) for x in v.flatten())

# -------------------- Modular helpers --------------------
MOD = 26

def mod_inv(a: int, m: int = MOD) -> int:
    # Extended Euclidean Algorithm for modular inverse
    a %= m
    if gcd(a, m) != 1:
        raise ValueError("No modular inverse: gcd(a, m) != 1")
    t, new_t = 0, 1
    r, new_r = m, a
    while new_r != 0:
        q = r // new_r
        t, new_t = new_t, t - q * new_t
        r, new_r = new_r, r - q * new_r
    return t % m

def mat_mod_inv(K: np.ndarray, m: int = MOD) -> np.ndarray:
    det = int(round(np.linalg.det(K)))  # determinant as integer
    det_mod = det % m
    inv_det = mod_inv(det_mod, m)
    # Adjugate: inv(K) = inv(det) * adj(K) (mod m)
    cof = np.zeros_like(K)
    for i in range(3):
        for j in range(3):
            minor = np.delete(np.delete(K, i, axis=0), j, axis=1)
            cof[i, j] = ((-1) ** (i + j)) * int(round(np.linalg.det(minor)))
    adj = cof.T
    return (inv_det * adj) % m

# -------------------- Hill cipher core --------------------

def hill_encrypt(plaintext: str, K: np.ndarray) -> str:
    s = pad_text(clean_text(plaintext), block=3)
    out = []
    for i in range(0, len(s), 3):
        P = to_vec3(s[i:i+3]) # 3x1
        C = (K @ P) % MOD     # 3x1
        out.append(from_vec3(C))
    return ''.join(out)

def hill_decrypt(ciphertext: str, K: np.ndarray) -> str:
    K_inv = mat_mod_inv(K)
    out = []
    for i in range(0, len(ciphertext), 3):
        C = to_vec3(ciphertext[i:i+3])
        P = (K_inv @ C) % MOD
        out.append(from_vec3(P))
    return ''.join(out)

# -------------------- Demo --------------------
K = np.array([[6, 24, 1],
              [13,16,10],
              [20,17,15]], dtype=int)

plaintext = "SECURE COMMUNICATION"
cipher = hill_encrypt(plaintext, K)
recovered = hill_decrypt(cipher, K)

print("Plaintext :", plaintext)
print("Clean+Pad:", pad_text(clean_text(plaintext), 3))
print("Cipher    :", cipher)
print("Decrypted :", recovered)
```

### ✅ Example Output

```
Plaintext : SECURE COMMUNICATION
Clean+Pad: SECURECOMMUNICATIONX
Cipher    : ZICVTWQNGRZGVTWAVZHCQYGLMGJ
Decrypted : SECURECOMMUNICATIONX
```

> Note: The trailing `X` is from padding so that the length is a multiple of 3.

---

## 🛠️ Practical Notes

* **Preserving spaces/punctuation**: If you need to preserve exact formatting, record the positions of non‑letters before encryption and re‑insert them after decryption.
* **Key validity**: If you choose your own key, verify `gcd(det(K), 26) = 1`. Otherwise decryption will fail.
* **Security**: The Hill cipher is educational and not secure against modern cryptanalysis.

---

## 🔁 What You Did (Summary)

1. **Converted** plaintext to A–Z (0–25), removed non‑letters, and **padded** to length multiple of 3.
2. **Encrypted** each 3‑letter block using matrix multiplication modulo 26.
3. **Decrypted** using the modular inverse of the key matrix.

That’s a full polygram substitution workflow with block size 3.
