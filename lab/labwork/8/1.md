# MD5 Oneâ€‘Way Hash â€” From Scratch + `hashlib` (Python)

> MD5 produces a 128â€‘bit digest from any input. It is **cryptographically broken** (collisions exist) and must **not** be used for security. Itâ€™s still useful for integrity/checksums in nonâ€‘adversarial settings. This guide shows:
>
> 1. A **fromâ€‘scratch** educational implementation per RFC 1321
> 2. The **correct, realâ€‘world** way using Pythonâ€™s `hashlib`

---

## âœ… Quick (Realâ€‘World) Usage â€” `hashlib`

```python
import hashlib

def md5_hex(data: bytes) -> str:
    return hashlib.md5(data).hexdigest()

print(md5_hex(b"hello"))  # -> 5d41402abc4b2a76b9719d911017c592
```

---

## ðŸ§© MD5 From Scratch (Educational)

**Algorithm outline:**

1. Pad the message (1 bit `0x80` then `0x00` bytes) so that length â‰¡ 448 (mod 512).
2. Append original **length in bits** as a 64â€‘bit **littleâ€‘endian** integer.
3. Initialize state (littleâ€‘endian 32â€‘bit words):

   * A = 0x67452301, B = 0xefcdab89, C = 0x98badcfe, D = 0x10325476
4. For each 512â€‘bit block, do 64 steps in 4 rounds using boolean funcs F,G,H,I, perâ€‘round shifts, and sineâ€‘based constants `T[i]`.
5. Output A,B,C,D concatenated in **littleâ€‘endian** as 128â€‘bit digest.

```python
from struct import pack, unpack
from math import sin

# --- helpers ---
MASK32 = 0xFFFFFFFF

def _left_rotate(x: int, n: int) -> int:
    x &= MASK32
    return ((x << n) | (x >> (32 - n))) & MASK32

# Boolean functions (RFC 1321)
F = lambda x, y, z: (x & y) | (~x & z)
G = lambda x, y, z: (x & z) | (y & ~z)
H = lambda x, y, z: x ^ y ^ z
I = lambda x, y, z: y ^ (x | ~z)

# Perâ€‘round leftâ€‘rotation amounts
S = [
    7,12,17,22, 7,12,17,22, 7,12,17,22, 7,12,17,22,  # Round 1
    5, 9,14,20, 5, 9,14,20, 5, 9,14,20, 5, 9,14,20,  # Round 2
    4,11,16,23, 4,11,16,23, 4,11,16,23, 4,11,16,23,  # Round 3
    6,10,15,21, 6,10,15,21, 6,10,15,21, 6,10,15,21   # Round 4
]

# Precompute T[i] = floor(2^32 * abs(sin(i+1)))
T = [int((1 << 32) * abs(sin(i + 1))) & MASK32 for i in range(64)]

# Message word index function per step
def _index(j: int) -> int:
    if 0 <= j <= 15:
        return j
    if 16 <= j <= 31:
        return (5*j + 1) % 16
    if 32 <= j <= 47:
        return (3*j + 5) % 16
    return (7*j) % 16

# Round function selector
FUNC = [F]*16 + [G]*16 + [H]*16 + [I]*16

class MD5:
    def __init__(self):
        self._A = 0x67452301
        self._B = 0xEFCDAB89
        self._C = 0x98BADCFE
        self._D = 0x10325476
        self._buf = b""
        self._length = 0  # in bytes

    def update(self, data: bytes):
        self._length += len(data)
        data = self._buf + data
        # process full 64â€‘byte blocks
        for i in range(0, len(data) // 64 * 64, 64):
            self._compress(data[i:i+64])
        self._buf = data[(len(data) // 64) * 64:]
        return self

    def _compress(self, block: bytes):
        X = list(unpack('<16I', block))  # 16 littleâ€‘endian 32â€‘bit words
        A, B, C, D = self._A, self._B, self._C, self._D
        for j in range(64):
            f = FUNC[j](B, C, D)
            idx = _index(j)
            temp = (A + f + X[idx] + T[j]) & MASK32
            A, D, C, B = D, C, B, (B + _left_rotate(temp, S[j])) & MASK32
        # add this chunk's hash to result so far
        self._A = (self._A + A) & MASK32
        self._B = (self._B + B) & MASK32
        self._C = (self._C + C) & MASK32
        self._D = (self._D + D) & MASK32

    def digest(self) -> bytes:
        # Pad: 0x80 then zeros, then 64â€‘bit length (bits) littleâ€‘endian
        bit_len = (self._length * 8) & ((1 << 64) - 1)
        pad = b"\x80" + b"\x00" * ((56 - (self._length + 1) % 64) % 64)
        tail = pad + pack('<Q', bit_len)
        self.update(tail)
        # Produce 16â€‘byte digest (A,B,C,D littleâ€‘endian)
        return pack('<4I', self._A, self._B, self._C, self._D)

    def hexdigest(self) -> str:
        return ''.join(f"{b:02x}" for b in self.digest())

# Convenience function
def md5_hex(data: bytes) -> str:
    return MD5().update(data).hexdigest()

# --- Selfâ€‘test with RFC 1321 vectors ---
if __name__ == "__main__":
    vectors = {
        b"": "d41d8cd98f00b204e9800998ecf8427e",
        b"a": "0cc175b9c0f1b6a831c399e269772661",
        b"abc": "900150983cd24fb0d6963f7d28e17f72",
        b"message digest": "f96b697d7cb7938d525a2f31aaf161d0",
        b"abcdefghijklmnopqrstuvwxyz": "c3fcd3d76192e4007dfb496cca67e13b",
        b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789": "d174ab98d277d9f5a5611c2c9f419d9f",
        b"12345678901234567890123456789012345678901234567890123456789012345678901234567890": "57edf4a22be3c955ac49da2e2107b67a",
    }
    ok = True
    for m, expected in vectors.items():
        h = md5_hex(m)
        print(m, h, ("OK" if h == expected else "FAIL"))
        ok &= (h == expected)
    print("All tests passed" if ok else "Some tests FAILED")
```

---

## ðŸ”’ Security Notes

* **Collisions** are practical; do **not** use MD5 for signatures, password hashing, or any adversarial setting.
* For secure hashing, use **SHAâ€‘256/512** (`hashlib.sha256`) or memoryâ€‘hard password hashers (**Argon2**, **scrypt**, **bcrypt**).

---

Both implementations should give the same hex digest; prefer `hashlib` in production.
