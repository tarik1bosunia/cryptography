# PGP‑Style Services in Python — Authentication, Confidentiality, and Both (Sign‑then‑Encrypt)

This is a **teaching** implementation that mirrors PGP’s key ideas:

* **Authentication**: hash + **digital signature** (sender proves authorship; receiver verifies)
* **Confidentiality**: **hybrid encryption** — random session key for fast symmetric encryption; session key is encrypted with recipient’s public key
* **Both**: **sign‑then‑encrypt** (PGP’s standard flow)

> ⚠️ For coursework. In production, use a real OpenPGP library. We use modern primitives (RSA‑OAEP, RSA‑PSS, AES‑256‑GCM, SHA‑256) to keep it safe by today’s standards while following the PGP steps conceptually.

---

## 📦 Dependencies

```bash
pip install cryptography
```

---

## 🧩 Code — PGP‑style Toolkit

```python
from __future__ import annotations
import base64, json, os, time, zlib
from dataclasses import dataclass
from typing import Tuple
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

# =============================
# Key Utilities (RSA 3072)
# =============================

def gen_rsa_keypair(bits: int = 3072):
    priv = rsa.generate_private_key(public_exponent=65537, key_size=bits)
    pub = priv.public_key()
    return priv, pub

def export_private_pem(priv) -> bytes:
    return priv.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption(),
    )

def export_public_pem(pub) -> bytes:
    return pub.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

# =============================
# Authentication (Signature)
# =============================

def sign_detached(message: bytes, sender_priv) -> bytes:
    """Return a detached RSA‑PSS signature over SHA‑256."""
    sig = sender_priv.sign(
        message,
        padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH),
        hashes.SHA256(),
    )
    return sig

def verify_detached(message: bytes, signature: bytes, sender_pub) -> bool:
    try:
        sender_pub.verify(
            signature,
            message,
            padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH),
            hashes.SHA256(),
        )
        return True
    except Exception:
        return False

# =============================
# Confidentiality (Hybrid Enc)
# =============================

@dataclass
class Envelope:
    version: int
    ts: int
    algo: str
    ek_b64: str  # RSA‑OAEP‑encrypted session key
    iv_b64: str
    ct_b64: str
    tag_b64: str
    comp: str  # "none" or "zlib"

    def to_bytes(self) -> bytes:
        return json.dumps(self.__dict__).encode("utf-8")

    @staticmethod
    def from_bytes(b: bytes) -> "Envelope":
        d = json.loads(b.decode("utf-8"))
        return Envelope(**d)


def encrypt_confidential(message: bytes, recipient_pub, compress: bool = True) -> bytes:
    # 1) (Optional) Compress (PGP typically compresses before encrypting)
    comp = "zlib" if compress else "none"
    payload = zlib.compress(message) if compress else message

    # 2) Generate random session key and nonce for AES‑GCM
    session_key = AESGCM.generate_key(bit_length=256)
    iv = os.urandom(12)

    # 3) Encrypt payload with AES‑256‑GCM
    aead = AESGCM(session_key)
    aad = b"PGP‑style‑envelope\x01"  # associated data (authenticated, not encrypted)
    ct = aead.encrypt(iv, payload, aad)  # returns ciphertext||tag
    ciphertext, tag = ct[:-16], ct[-16:]

    # 4) Encrypt session key with recipient RSA‑OAEP (SHA‑256)
    ek = recipient_pub.encrypt(
        session_key,
        padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None),
    )

    env = Envelope(
        version=1,
        ts=int(time.time()),
        algo="RSA‑OAEP+AES‑256‑GCM",
        ek_b64=base64.b64encode(ek).decode(),
        iv_b64=base64.b64encode(iv).decode(),
        ct_b64=base64.b64encode(ciphertext).decode(),
        tag_b64=base64.b64encode(tag).decode(),
        comp=comp,
    )
    return base64.b64encode(env.to_bytes())  # ASCII‑armored blob


def decrypt_confidential(blob_b64: bytes, recipient_priv) -> bytes:
    env = Envelope.from_bytes(base64.b64decode(blob_b64))

    ek = base64.b64decode(env.ek_b64)
    iv = base64.b64decode(env.iv_b64)
    ct = base64.b64decode(env.ct_b64)
    tag = base64.b64decode(env.tag_b64)

    # 1) Decrypt session key with recipient RSA‑OAEP
    session_key = recipient_priv.decrypt(
        ek,
        padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None),
    )

    # 2) Decrypt payload with AES‑GCM
    aead = AESGCM(session_key)
    aad = b"PGP‑style‑envelope\x01"
    pt = aead.decrypt(iv, ct + tag, aad)

    # 3) Decompress if needed
    if env.comp == "zlib":
        pt = zlib.decompress(pt)
    return pt

# =========================================
# Both: Sign‑then‑Encrypt (PGP practice)
# =========================================

def sign_then_encrypt(message: bytes, sender_priv, recipient_pub, compress: bool = True) -> bytes:
    # a) Authentication: detached signature over the *raw* message
    sig = sign_detached(message, sender_priv)
    packet = json.dumps({
        "msg_b64": base64.b64encode(message).decode(),
        "sig_b64": base64.b64encode(sig).decode(),
    }).encode("utf-8")
    # b) Confidentiality: encrypt the packet as the payload
    return encrypt_confidential(packet, recipient_pub, compress=compress)


def decrypt_then_verify(blob_b64: bytes, recipient_priv, sender_pub) -> Tuple[bytes, bool]:
    packet = decrypt_confidential(blob_b64, recipient_priv)
    d = json.loads(packet.decode("utf-8"))
    msg = base64.b64decode(d["msg_b64"])
    sig = base64.b64decode(d["sig_b64"])
    ok = verify_detached(msg, sig, sender_pub)
    return msg, ok

# =============================
# Demo
# =============================
if __name__ == "__main__":
    # Generate keys for Alice (sender) and Bob (recipient)
    alice_priv, alice_pub = gen_rsa_keypair()
    bob_priv, bob_pub = gen_rsa_keypair()

    plaintext = b"PGP demo: বাংলা supported if UTF‑8 kept as bytes. Sign, encrypt, verify, decrypt."

    # (a) Authentication only
    sig = sign_detached(plaintext, alice_priv)
    print("Auth: signature bytes:", base64.b64encode(sig)[:40].decode(), "...")
    print("Verify:", verify_detached(plaintext, sig, alice_pub))

    # (b) Confidentiality only
    blob = encrypt_confidential(plaintext, bob_pub, compress=True)
    recov = decrypt_confidential(blob, bob_priv)
    print("Conf: recovered == plaintext?", recov == plaintext)

    # (c) Both (sign‑then‑encrypt)
    blob2 = sign_then_encrypt(plaintext, alice_priv, bob_pub, compress=True)
    msg, ok = decrypt_then_verify(blob2, bob_priv, alice_pub)
    print("Both: verify ok?", ok, "| recovered == plaintext?", msg == plaintext)

    # Show ASCII‑armored blob size
    print("Armored size (bytes):", len(blob2))
```

```

---

## 🔍 How this matches PGP steps
- **Authentication**: hash (SHA‑256 inside RSA‑PSS) + **digital signature** with sender’s private key; receiver verifies with sender’s public key.
- **Confidentiality**: **hybrid** design — random **session key** for AES‑256‑GCM; session key is **RSA‑OAEP**‑encrypted to the recipient; result is **ASCII‑armored** (base64 JSON) similar to PGP’s ASCII armor.
- **Both**: **sign‑then‑encrypt** — the signature is over the original plaintext, then the whole (message + signature) packet is encrypted.

> Optional PGP features like **compression** are included (zlib before encrypt).

---

## 🧪 Running
1. Install dependency: `pip install cryptography`
2. Run: `python pgp_services.py`
3. You’ll see signature verification, confidentiality round‑trip, and sign‑then‑encrypt success.

---

## ⚠️ Notes
- Textbook PGP also supports multiple recipients and key IDs; we keep a single‑recipient minimal envelope for clarity.
- We use **RSA‑PSS** (signatures) and **RSA‑OAEP** (key encapsulation) with **SHA‑256**, which are modern, secure choices compared to legacy PKCS#1 v1.5.
- For real OpenPGP workflows (keyrings, fingerprints, revocation, armored blocks), use libraries like `pgpy` or GnuPG bindings.

```
