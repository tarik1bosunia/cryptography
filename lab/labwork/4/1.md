# 🔐 Double Transposition Cipher (with two columnar permutations)

We’ll encrypt and decrypt the given plaintext using a **double columnar transposition**. You provide **two keywords** (or widths); the text is first transposed by the first keyword, then by the second. Decryption reverses the order.

Plaintext (given):

> **DEPARTMENT OF COMPUTER SCIENCE AND TECHNOLY UNIVERSITY OF RAJSHAHI BANGLADESH**

---

## 🧹 Preprocessing

* Uppercase A–Z only (spaces/punctuation removed for the transform).
* Pad with a filler (default **X**) so that the total length is a multiple of **LCM(len(key1), len(key2))**. This guarantees rectangular grids for both steps.

---

## 🔑 Column Order from a Keyword

For a keyword like `SECURE`, compute the **column order** by sorting letters alphabetically. Ties are broken by left‑to‑right position (stable sort). Example: `SECURE` → letters: `E, C, R, S, U, E` sorted with indices gives an order vector like `[1, 5, 2, 0, 4, 3]` (implementation computes this robustly).

---

## 🧩 Python Implementation (Encryption & Decryption)

```python
import math
from typing import List

ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
PAD = "X"

# ---------- Helpers ----------
def clean_text(s: str) -> str:
    s = s.upper()
    return "".join(ch for ch in s if ch in ALPHA)

def lcm(a: int, b: int) -> int:
    import math
    return a * b // math.gcd(a, b)

# Column order as a permutation of indices 0..m-1
# Stable sort on (char, original_index)

def column_order(keyword: str) -> List[int]:
    pairs = list(enumerate(keyword.upper()))  # [(idx, char), ...]
    # sort by char then by idx to break ties stably
    pairs_sorted = sorted(pairs, key=lambda p: (p[1], p[0]))
    # order[i] = position (rank) of column i in the sorted list
    order = [None] * len(keyword)
    for rank, (orig_i, _c) in enumerate(pairs_sorted):
        order[orig_i] = rank
    return order

# Inverse permutation: inv[p[i]] = i

def inverse_perm(p: List[int]) -> List[int]:
    inv = [0]*len(p)
    for i, v in enumerate(p):
        inv[v] = i
    return inv

# ---------- Single Columnar Transposition ----------
# We assume len(text) is a multiple of m (len(keyword))

def col_encrypt(text: str, keyword: str) -> str:
    m = len(keyword)
    order = column_order(keyword)
    rows = len(text) // m
    # Build rows
    grid = [text[r*m:(r+1)*m] for r in range(rows)]
    # Read columns in increasing order of order index
    # compute column index sequence: for rank 0..m-1, which original column?
    col_seq = inverse_perm(order)
    out = []
    for c in col_seq:
        for r in range(rows):
            out.append(grid[r][c])
    return "".join(out)

# For decryption, reconstruct columns by the same order

def col_decrypt(cipher: str, keyword: str) -> str:
    m = len(keyword)
    order = column_order(keyword)
    rows = len(cipher) // m
    # Cipher is arranged as m consecutive columns of length rows, in the order col_seq
    col_seq = inverse_perm(order)  # sequence of original column indices by rank
    cols = [None]*m
    idx = 0
    for rank, c in enumerate(col_seq):
        cols[c] = cipher[idx:idx+rows]
        idx += rows
    # Read row-wise
    out = []
    for r in range(rows):
        for c in range(m):
            out.append(cols[c][r])
    return "".join(out)

# ---------- Double Transposition ----------

def double_transpose_encrypt(plaintext: str, key1: str, key2: str, pad: str = PAD) -> tuple[str, str]:
    s = clean_text(plaintext)
    m1, m2 = len(key1), len(key2)
    block = lcm(m1, m2)
    # pad to multiple of lcm for rectangular matrices in both steps
    rem = len(s) % block
    if rem != 0:
        s = s + pad * (block - rem)
    # First columnar transposition
    c1 = col_encrypt(s, key1)
    # Second columnar transposition
    c2 = col_encrypt(c1, key2)
    return c2, s

def double_transpose_decrypt(cipher: str, key1: str, key2: str, pad: str = PAD) -> str:
    # Reverse order of keys
    p1 = col_decrypt(cipher, key2)
    p2 = col_decrypt(p1, key1)
    # strip trailing pad
    return p2.rstrip(pad)

# ---------------- Demo on given plaintext ----------------
PT = "DEPARTMENT OF COMPUTER SCIENCE AND TECHNOLY UNIVERSITY OF RAJSHAHI BANGLADESH"
key1 = "SECURE"      # you can change
key2 = "RAJSHAHI"    # you can change

cipher, padded = double_transpose_encrypt(PT, key1, key2)
recovered = double_transpose_decrypt(cipher, key1, key2)

print("Key1 / Key2 :", key1, "/", key2)
print("Clean+Pad  :", padded)
print("Ciphertext :", cipher)
print("Recovered  :", recovered)
```

---

## 🧪 How it Works (Conceptually)

1. **Clean** the plaintext (A–Z only), then **pad** so its length is a multiple of `lcm(len(key1), len(key2))`.
2. **First transposition** (key1): fill the matrix row‑wise with `m1 = len(key1)` columns, then read columns in the alphabetical order of key1’s letters.
3. **Second transposition** (key2): take the result and do the same with `m2 = len(key2)`.
4. **Decryption**: apply the inverse order—first undo key2, then undo key1—and strip padding.

---

## 🛠 Tips & Variants

* **Preserve spaces/punctuation**: store their indices before cleaning; after decryption, re‑insert them.
* **Duplicate letters in keys** are handled by stable sorting, so the permutation is well‑defined.
* If you prefer **numeric widths** instead of keywords, you can set keys as repeated characters of that length (e.g., `"A"*8`) or adapt `col_encrypt` to take a numeric permutation directly.

---

## ✅ What to Submit

1. Your chosen **key1** and **key2**.
2. The **cleaned + padded** plaintext.
3. The final **ciphertext**.
4. The **recovered** plaintext showing correctness.

> Change `key1`/`key2` and re-run to see different outputs. Decryption will match the cleaned original when padding is removed.
