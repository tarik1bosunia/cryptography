# ðŸ” Oneâ€‘Time Pad (OTP) â€” Encrypt & Decrypt (Key from File)

This guide shows how to encrypt and decrypt text using the **Oneâ€‘Time Pad (OTP)** when you are given a file containing a large, nonâ€‘repeating set of **truly random key letters** (Aâ€“Z). The code reads the key from the file, uses as many letters as needed, and then reverses the process to recover the original plaintext.

> âœ… **Security properties (OTP):** Perfect secrecy **only if** the key is truly random, **at least** as long as the message, used **exactly once**, and kept **completely secret**.

---

## ðŸ§¹ Conventions & Choices

* Alphabet: **Aâ€“Z â†’ 0â€“25**.
* We **preserve punctuation, digits, spaces**: key advances only when encrypting a letter `[Aâ€“Z/aâ€“z]`; nonâ€‘letters are copied asâ€‘is.
* Case is preserved in the output.
* Arithmetic is **mod 26**.

---

## ðŸ§© Python Implementation

```python
from pathlib import Path
from typing import Tuple

ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
A = ord('A')

def read_key_letters(path: str) -> str:
    """Read a key file and return only Aâ€“Z letters in uppercase.
    The file may contain whitespace/punctuation; they are ignored.
    """
    s = Path(path).read_text(encoding='utf-8', errors='ignore')
    s = s.upper()
    return ''.join(ch for ch in s if ch in ALPHA)

# ---- helpers ----

def ch2num(ch: str) -> int:
    return ord(ch) - A

def num2ch(n: int, upper: bool) -> str:
    ch = chr((n % 26) + A)
    return ch if upper else ch.lower()

def otp_core(plaintext: str, keystream: str) -> Tuple[str, int]:
    """Return ciphertext and number of key letters consumed.
    We advance the keystream only for alphabetic characters.
    """
    out = []
    k = 0  # index into keystream
    for ch in plaintext:
        if ch.isalpha():
            upper = ch.isupper()
            p = ch2num(ch.upper())
            if k >= len(keystream):
                raise ValueError("Key exhausted: provide a longer key file or shorter plaintext.")
            kval = ch2num(keystream[k])
            c = (p + kval) % 26
            out.append(num2ch(c, upper))
            k += 1
        else:
            out.append(ch)
    return ''.join(out), k

def otp_encrypt_text(plaintext: str, keyfile: str) -> Tuple[str, int]:
    key = read_key_letters(keyfile)
    if not key:
        raise ValueError("Key file contains no Aâ€“Z letters.")
    return otp_core(plaintext, key)

def otp_decrypt_text(ciphertext: str, keyfile: str) -> Tuple[str, int]:
    key = read_key_letters(keyfile)
    if not key:
        raise ValueError("Key file contains no Aâ€“Z letters.")
    # Decryption: subtract the same keystream (i.e., add 26 - k)
    # Implement by reusing otp_core with modified keystream: K' = (-K mod 26)
    inv_key = ''.join(ALPHA[(26 - ch2num(k)) % 26] for k in key)
    return otp_core(ciphertext, inv_key)

# ------------- Demo -------------
# Provide your key in a file, e.g., "otp_key.txt" with random Aâ€“Z letters (no repeats needed, but MUST be long enough).
# Example plaintext (you can replace with any text):
PT = "Attack at dawn! Bring 2 boats."  # punctuation, digits preserved
key_path = "otp_key.txt"

# Encrypt
try:
    CT, used_enc = otp_encrypt_text(PT, key_path)
    print("Plaintext :", PT)
    print("Ciphertext:", CT)
    print(f"Key used  : {used_enc} letters")

    # Decrypt (must use the **same** key file and consume letters in the same order)
    RT, used_dec = otp_decrypt_text(CT, key_path)
    print("Recovered :", RT)
    print(f"Key used  : {used_dec} letters")
except Exception as e:
    print("Error:", e)
```

---

## ðŸ”Ž How It Works

1. **Key file** is read and filtered to **Aâ€“Z uppercase** letters only.
2. For each **letter** in plaintext: map to 0â€“25, **add** the next key letter (0â€“25) modulo 26, and output a letter. Case is preserved.
3. For **nonâ€‘letters** (spaces, digits, punctuation): copy directly; **do not** consume key.
4. **Decryption** uses the **same key** but subtracts each key letter modulo 26 (implemented by forming an inverse key stream `K' = âˆ’K mod 26`).

---

## âœ… Correctness Check

* If you run the demo with a sufficiently long key file, the `Recovered` text will match the original plaintext exactly (including spaces, punctuation, and case).
* The printouts show how many key letters were consumed. Your key file must contain **at least** that many letters.

---

## ðŸ”’ Security Checklist (Very Important)

* **Truly random key**: Use a highâ€‘quality source of randomness. Do **not** use predictable generators.
* **Key length** â‰¥ number of plaintext **letters** (since we skip nonâ€‘letters).
* **Never reuse** any portion of the key on a different message.
* **Keep key secret** and destroy used parts; OTP is only perfectly secure under these conditions.

---

## ðŸ’¡ Variants

* **Bytesâ€‘level OTP (XOR)**: For general binary data, use a binary key and XOR each byte (`cipher = plaintext ^ key`). The letterâ€‘based version above is for educational/classical ciphers.
* **Key consumption tracking**: In real workflows, track how many characters of the key youâ€™ve used and **advance** the file pointer for the next message so you never reuse.

---

## ðŸ§ª Quick Usage Steps

1. Create a file `otp_key.txt` with at least N random letters, where N = count of alphabetic characters in your message.
2. Set `key_path = "otp_key.txt"` and `PT = "your plaintext"`.
3. Run the script to get the ciphertext and verify decryption.

Thatâ€™s a complete Oneâ€‘Time Pad workflow using a key file of random letters.
